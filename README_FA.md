# گوست‌وایر - تونل معکوس ضد سانسور

گوست‌وایر یک سیستم تونل معکوس مبتنی بر WebSocket است که به کاربران در کشورهای دارای سانسور کمک می‌کند تا به اینترنت آزاد دسترسی پیدا کنند. این سیستم از اتصالات WebSocket امن روی TLS استفاده می‌کند که تشخیص و مسدود کردن آن دشوار است.

## ویژگی‌ها

- **پشتیبانی از پروتکل‌های متعدد** - WebSocket، HTTP/2 و gRPC

- **احراز هویت رمزگذاری شده با RSA** - توکن برای پروکسی‌های خاتمه‌دهنده TLS (مانند CloudFlare) نامرئی است

- **رمزگذاری سرتاسری AES-256-GCM** - تمام داده‌های تونل با کلیدهای مشتق شده از PBKDF2 رمزگذاری شده‌اند

- **معماری تونل معکوس** - کلاینت به سرور متصل می‌شود (مسدودسازی خروجی را دور می‌زند)

- **جریان دوطرفه** - یک اتصال مداوم روی TLS

- **هدایت پورت TCP انعطاف‌پذیر** - محدوده پورت، اتصال IP، نگاشت‌های سفارشی

- **نبض داخلی** - نگهداشت زنده در لایه انتقال و لایه برنامه

- **سازگار با CloudFlare** - با پروکسی‌های خاتمه‌دهنده TLS (با WebSocket/HTTP/2) کار می‌کند

- **پنل مدیریت وب** - پایش سیستم بلادرنگ، تنظیم تونل، لاگ‌ها، کنترل سرویس

- **معکوس‌پروکسی nginx** - راه‌اندازی آماده تولید با Let's Encrypt

- **فایل‌های باینری کامپایل شده** - Linux amd64 (سازگار با Ubuntu 22.04+)

- **سرویس‌های systemd** - شروع خودکار، راه‌اندازی مجدد، لاگ‌نویسی

- **به‌روزرسانی خودکار** - به‌روزرسانی خودکار فایل باینری از طریق انتشارهای GitHub

- **نصب آسان** - اسکریپت‌های راه‌اندازی یک دستوری با تنظیمات تعاملی

## شروع سریع

### مرحله ۱: نصب سرور (کشور دارای سانسور - مثلاً ایران)

سرور در کشور دارای سانسور با IP عمومی اجرا می‌شود که می‌تواند اتصالات ورودی را دریافت کند.

```bash
wget https://github.com/frenchtoblerone54/ghostwire/releases/latest/download/install-server.sh -O install-server.sh
chmod +x install-server.sh
sudo ./install-server.sh
```

**نکته:** توکن احراز هویت را ذخیره کنید - برای کلاینت به آن نیاز دارید!

### مرحله ۲: نصب کلاینت (کشور بدون سانسور - مثلاً هلند، آمریکا)

کلاینت روی یک VPS در کشور بدون سانسور با دسترسی نامحدود به اینترنت اجرا می‌شود.

```bash
wget https://github.com/frenchtoblerone54/ghostwire/releases/latest/download/install-client.sh -O install-client.sh
chmod +x install-client.sh
sudo ./install-client.sh
```

وارد کنید:

- **آدرس سرور** که به سرور ایران شما اشاره می‌کند (مثلاً `wss://iran-server.com/ws`)

- **توکن احراز هویت** از سرور

- کلاینت به سرور ایران متصل می‌شود

### مرحله ۳: استفاده از تونل (در ایران)

کاربران در ایران به پورت‌های محلی سرور (مثلاً `localhost:8080`) متصل می‌شوند و ترافیک از طریق تونل به کلاینت NL هدایت می‌شود که درخواست‌های واقعی اینترنت را انجام می‌دهد.

## مستندات

- [راهنمای نصب](/FrenchToblerone54/ghostwire/blob/main/docs/installation.md) - دستورالعمل‌های دقیق نصب برای سرور و کلاینت

- [مرجع تنظیمات](/FrenchToblerone54/ghostwire/blob/main/docs/configuration.md) - گزینه‌های کامل تنظیمات

- [عیب‌یابی](/FrenchToblerone54/ghostwire/blob/main/docs/troubleshooting.md) - مشکلات رایج و راه‌حل‌ها

- [امنیت](/FrenchToblerone54/ghostwire/blob/main/docs/security.md) - جزئیات رمزنگاری و ملاحظات امنیتی

## معماری

### تونل معکوس برای دور زدن مسدودسازی خروجی

برای سناریوهایی طراحی شده است که کشورهای دارای سانسور اتصالات خروجی به سرورهای خارجی را مسدود می‌کنند (مثلاً ایران اتصالات به وب‌سایت‌های بین‌المللی را مسدود می‌کند).

#### راه‌اندازی:

- **سرور:** در کشور دارای سانسور (ایران) با IP عمومی اجرا می‌شود

- **کلاینت:** در کشور بدون سانسور (هلند) با دسترسی نامحدود به اینترنت اجرا می‌شود

#### چرا این کار می‌کند؟

- ایران اتصالات خروجی به سرورهای خارجی را مسدود می‌کند

- اما سرور ایران IP عمومی دارد و می‌تواند اتصالات WebSocket ورودی را دریافت کند

- کلاینت NL به سرور ایران متصل می‌شود (ورودی به ایران = مجاز ✅)

- پس از برقراری تونل، ترافیک دوطرفه جریان می‌یابد

#### جریان داده‌ها:

```
[کاربر در ایران] → [سرور localhost:8080] → [سرور ایران]
       ↓ تونل WebSocket
[کلاینت NL] → [اینترنت: پورت 80/443]
```

#### گام به گام:

۱. کلاینت (NL) اتصال WebSocket را به سرور (ایران) آغاز می‌کند

۲. سرور (ایران) روی پورت‌های محلی (مثلاً 8080) برای کاربران گوش می‌دهد

۳. کاربر در ایران به localhost:8080 متصل می‌شود

۴. ترافیک از طریق WebSocket به کلاینت NL تونل می‌شود

۵. کلاینت NL اتصال واقعی به وب‌سایت‌های مسدود شده برقرار می‌کند

۶. پاسخ از طریق تونل به کاربر برمی‌گردد

CloudFlare/DNS: به IP سرور ایران اشاره می‌کند (جایی که سرور WebSocket برای اتصالات کلاینت گوش می‌دهد)

## نحو نگاشت پورت

سرور تنظیمات نگاشت پورت انعطاف‌پذیر را پشتیبانی می‌کند (سرور گوش می‌دهد، کلاینت متصل می‌شود):

```toml
ports=[
    "443-600",              # گوش دادن روی تمام پورت‌های 443-600، ارسال به همان پورت در ریموت
    "443-600:5201",         # گوش دادن روی تمام پورت‌های 443-600، ارسال همه به پورت ریموت 5201
    "443-600=1.1.1.1:5201", # گوش دادن روی تمام پورت‌های 443-600، ارسال همه به 1.1.1.1:5201
    "443",                   # گوش دادن روی پورت محلی 443، ارسال به پورت ریموت 443
    "4000=5000",             # گوش دادن روی پورت محلی 4000، ارسال به پورت ریموت 5000
    "127.0.0.2:443=5201",    # اتصال به 127.0.0.2:443، ارسال به پورت ریموت 5201
    "443=1.1.1.1:5201",      # گوش دادن روی پورت محلی 443، ارسال به 1.1.1.1:5201
    "127.0.0.2:443=1.1.1.1:5201", # اتصال به 127.0.0.2:443، ارسال به 1.1.1.1:5201
]
```

## تنظیمات

### تنظیمات سرور (/etc/ghostwire/server.toml)

**مکان:** کشور دارای سانسور (ایران) - IP عمومی دارد، برای اتصالات کلاینت گوش می‌دهد

```toml
[server]
protocol="websocket"        # "websocket" (پیش‌فرض)، "http2" یا "grpc"
listen_host="0.0.0.0"
listen_port=8443
listen_backlog=4096         # عمق صف گوش دادن TCP
websocket_path="/ws"        # فقط برای پروتکل websocket استفاده می‌شود
ping_interval=30            # فاصله پینگ سطح برنامه (ثانیه)
ping_timeout=60             # تایم‌اوت اتصال (ثانیه)
ws_pool_enabled=true        # فعال کردن استخر کانال فرزند (پیش‌فرض: true)
ws_pool_children=8          # حداکثر کانال‌های WebSocket موازی
ws_pool_min=2               # حداقل کانال‌های همیشه متصل (پیش‌فرض: 2)
ws_pool_stripe=false        # خط زدن پکت‌ها در کانال‌ها (ناپایدار، پیش‌فرض: false)
udp_enabled=true            # همچنین برای UDP روی پورت‌های تونل گوش می‌دهد (پیش‌فرض: true)
auto_update=true
update_check_interval=300
update_check_on_startup=true

[auth]
token="V1StGXR8_Z5jdHi6B-my"

[tunnels]
ports=["8080=80", "8443=443"]

[panel]
enabled=true
host="127.0.0.1"
port=9090
path="aBcDeFgHiJkLmNoPqRsT"
threads=4                  # رشته‌های کارگر سرور HTTP

[logging]
level="info"
file="/var/log/ghostwire-server.log"
```

### تنظیمات کلاینت (/etc/ghostwire/client.toml)

**مکان:** کشور بدون سانسور (هلند) - به سرور متصل می‌شود، درخواست‌های اینترنت را انجام می‌دهد

```toml
[server]
protocol="websocket"        # "websocket" (پیش‌فرض)، "http2" یا "grpc"
url="wss://tunnel.example.com/ws"  # از wss:// برای websocket، https:// برای http2/grpc استفاده کنید
token="V1StGXR8_Z5jdHi6B-my"
ping_interval=30            # فاصله پینگ سطح برنامه (ثانیه)
ping_timeout=60             # تایم‌اوت اتصال (ثانیه)
auto_update=true
update_check_interval=300
update_check_on_startup=true

[reconnect]
initial_delay=1
max_delay=60
multiplier=2

[cloudflare]
enabled=false
ips=[]
host=""
check_interval=300
max_connection_time=1740

[logging]
level="info"
file="/var/log/ghostwire-client.log"
```

## گزینه‌های پروتکل

گوست‌وایر از سه پروتکل انتقال پشتیبانی می‌کند، هر کدام با معاملات متفاوت:

### پروتکل WebSocket (protocol="websocket") - پیش‌فرض

بهترین برای: CloudFlare، استفاده عمومی، حداکثر سازگاری

- ✅ با CloudFlare کار می‌کند (نیاز به فعال بودن WebSockets دارد)

- ✅ ابزارهای اشکال‌زدایی مبتنی بر مرورگر ساده در دسترس است

- ✅ به طور گسترده‌ای توسط پروکسی‌ها و لود بالانسرها پشتیبانی می‌شود

- ❌ پروکسی‌های فقط HTTP/2 ممکن است ارتقا WebSocket را مسدود کنند (باعث HTTP 426 می‌شود)

- ❌ نیاز به مدیریت هدر Upgrade ویژه در nginx دارد

### پروتکل HTTP/2 (protocol="http2") - اتصال مستقیم

بهترین برای: اتصالات مستقیم بدون CloudFlare، راه‌اندازی پروکسی سفارشی

- ✅ جریان‌های بومی HTTP/2 (بدون دستکش WebSocket)

- ✅ ابزارهای اشکال‌زدایی پروتکل ساده در دسترس است

- ✅ بدون سربار protobuf

- ❌ **سازگار با CloudFlare نیست** (جریان‌های خام HTTP/2 پشتیبانی نمی‌شوند)

- ❌ نیاز به پروکسی یا اتصال مستقیم HTTP/2 دارد

### پروتکل gRPC (protocol="grpc") - بهینه‌سازی شده برای CloudFlare

بهترین برای: CloudFlare با gRPC فعال، سناریوهای عملکرد بالا

- ✅ سازگار با CloudFlare (نیاز به Network → gRPC فعال دارد)

- ✅ بالاترین کارایی пропуск (سریال‌سازی protobuf)

- ✅ مولتیپلکسینگ جریان داخلی

- ✅ کمترین سربار پروتکل

- ❌ نیاز به تغییر گRPC CloudFlare یا پروکسی آگاه از gRPC دارد

- ❌ اشکال‌زدایی پیچیده‌تر

## مدیریت systemd

### سرور:

```bash
sudo systemctl start ghostwire-server
sudo systemctl stop ghostwire-server
sudo systemctl restart ghostwire-server
sudo systemctl status ghostwire-server
sudo journalctl -u ghostwire-server -f
```

### کلاینت:

```bash
sudo systemctl start ghostwire-client
sudo systemctl stop ghostwire-client
sudo systemctl restart ghostwire-client
sudo systemctl status ghostwire-client
sudo journalctl -u ghostwire-client -f
```

## مجوز

MIT License - جزئیات در فایل LICENSE

## مشارکت

مشارکت‌ها خوش‌آمد هستند! لطفاً یک issue باز کنید یا یک pull request ارسال کنید.

## پشتیبانی

برای مشکلات و سؤالات، لطفاً یک issue در GitHub باز کنید.
